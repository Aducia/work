#include <Adafruit_NeoPixel.h> 

#define LED_PIN 4
// 1.задаємо пін, до якого підключили кільце\

#define NUM_LEDS 24
// 2.задаємо кількість діодів

#define BUTTON_PIN 12
// 3.знаходимо кнопку, зазначаємо, що вона підключена до 2 піна

Adafruit_NeoPixel ring1(NUM_LEDS, LED_PIN, NEO_RGB + NEO_KHZ800);
// 3.задаємо параметри світлодіодного кільця:
// кількість світлодіодів і порт, до якого підключили кільце, 
//а також технічна інформація (тип палітри (RGB) і частота оновлення кільця).


//  тепер прописуємо логіку. Ініціалізовуємо змінні.
int startindex = 0;
//4.індекс початкового світлодіоду в даний момент

int sametimelight = 1;
//5.скільки світлодіодів світять одночасно, починаємо лічити з 1

int ledState = HIGH;        // the current state of the output pin
int buttonState;            // the current reading from the input pin
int lastButtonState = LOW;  // the previous reading from the input pin

unsigned long lastDebounceTime = 0;
//7. останній раз коли стан кнопки змінився. 
//Але нас цікавить ще час стабільності кнопки, а мінімальний він в 50 мс,
//тому додаємо сталу і наступну змінну, яка запам'ятовуватиме запам’ятовує, коли востаннє оновлювався рух бігаючого вогника
const unsigned long debounceDelay = 50; 
unsigned long previousMillis = 0;

const unsigned long interval = 75;
//інтервал між вогниками

// Додатково: зберігаємо останнє не-стабілізоване зчитування
int lastReading = HIGH;
// останнє фізичне зчитування кнопки (для debounce)

void setup()
{// щоб працювати з кільцем варто його ініціалізувати
  ring1.begin();
  // запускаємо бібліотеку NeoPixel
  ring1.show(); 
  //нічого не передаємо в аргументи, тоді всі світлодіоди вимкнені.
  
 pinMode(BUTTON_PIN, INPUT_PULLUP); // кнопка з підтягуванням (натиснута = LOW)
 
 // Налаштовуємо додатковий звичайний LED (якщо потрібен)
 pinMode(LED_PIN, OUTPUT);
 // встановлюємо початковий стан звичайного LED
 digitalWrite(LED_PIN, ledState);
}

void loop()
{
  // читаємо поточний фізичний стан кнопки
  int reading = digitalRead(BUTTON_PIN); 
    // ініціалізуємо змінну, щоб читати і записувати туди поточний стан піна,
    // далі перевіряємо істинність: 

  if (reading != lastReading) {
    lastDebounceTime = millis();
  } 
 // якщо функція не дорівнює останньому положенню кнопки (0 чи 1), то ми змінюємо змінну час в який відбулася зміна,
 // тобто кажемо, ми запам'ятали,що востаннє кнопка змінила положення в такий то час
  //Або можлива інша умова
// якщо час в який кнопка не змюню свій стан (лишається стабільною), то ми вважатимемо кнопку натисненою
//щоб дізнатися, чи стабільна кнопка варто від загалоного часу роботи відняти час останньої зміни кнопки  і якщо це більше ніж мінімальний інтервал натисків, то умова справджується  
  if ((millis() - lastDebounceTime) > debounceDelay) {
    // Якщо стабільний стан фізично відрізняється від збереженого buttonState — оновлюємо
    if (reading != buttonState) {
      buttonState = reading;
      // Реагуємо тільки на перехід HIGH -> LOW (INPUT_PULLUP: натиснута = LOW)
      if (buttonState == LOW) {
        sametimelight++;               // збільшуємо кількість одночасних вогників
        if (sametimelight > NUM_LEDS) {
          sametimelight = 1;           // якщо більше NUM_LEDS — скидаємо до 1
        }
      }
    }
  }

  lastReading = reading; // оновлюємо останнє необроблене зчитування

  // показуємо стан додаткового LED (як у тебе)
  digitalWrite(LED_PIN, ledState);

  // save the reading. Next time through the loop, it'll be the lastButtonState:
  lastButtonState = reading;


  // тепер робимо анімацію на кільці
  if ((millis() - previousMillis) >= interval) {
    previousMillis = millis();

    // Очищаємо кільце
    ring1.clear();
    
    // Вмикаємо sametimelight пікселів, починаючи з startindex
    for (int i = 0; i <= 12; i++) {
      int index = (startindex + i) % NUM_LEDS;
      ring1.setPixelColor(index, ring1.Color(0, 255, 255)); }
    // встановлюємо колір ( блакитний)
    

    ring1.show();
    // цикл для засвічення i-того світлодіода. Починаємо рахувати з 0, і до 11. Логіка проста: поки не сягне sametimelight — додаємо ще один світлодіод до роботи.
    // show функція завжди використовується без параметрів, але тільки завдяки ній має сенс попередня,
    // бо інакше те що ми задали до цього не відобразиться на світлодіодах

    // Зсуваємо стартову позицію на 1 для наступного кадру
    startindex = (startindex + 1) % NUM_LEDS;
  } // кінець інтервального оновлення

}

пурумпум щось поредаговано

    